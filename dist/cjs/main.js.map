{"version":3,"file":"main.js","sources":["../../src/utils/svg-util.js","../../src/graph-events.js","../../src/utils/traverse.js","../../src/svg-renderer.js","../../src/utils/removeChildren.js","../../src/addons/group.js"],"sourcesContent":["import * as d3 from 'd3';\n\n/* SVG Utility functions */\n\n/**\n * Chart wrapper\n * @param {object} svg - D3 svg selection\n * @param {number} w - width\n * @param {number} h - height\n * @param {object} viewport - optional x1, y1, x2, y2.\n */\nexport const createChart = (svg, w, h, viewport = {}) => {\n  svg.attr('width', w + 'px');\n  svg.attr('height', h + 'px');\n\n  const x1 = viewport.x1 || 0;\n  const y1 = viewport.y1 || 0;\n  const x2 = viewport.x2 || w;\n  const y2 = viewport.y2 || h;\n\n  svg.attr('preserveAspectRatio', 'xMinYMin meet');\n  svg.attr('viewBox', `${x1} ${y1} ${x2} ${y2}`);\n  svg.append('defs');\n\n  return svg;\n};\n\nexport const translate = (x, y) => { return `translate(${x}, ${y})`; };\n\nexport const line = (x1, y1, x2, y2) => {\n  return 'M' + x1 + ',' + y1 + 'L' + x2 + ',' + y2;\n};\n\n// A path generator\nexport const pathFn = d3.line()\n  .x(d => d.x)\n  .y(d => d.y);\n\n\n// Pre-canned path/glyphs, we assume all paths are bounded by a 10x10 grid and centered at (0, 0)\n// - Arrows point left-to-right\nexport const MARKER_VIEWBOX = '-5 -5 10 10';\nexport const ARROW = 'M 0,-3.25 L 5 ,0 L 0,3.25';\nexport const ARROW_SHARP = 'M 0,-3 L 5 ,0 L 0,3 L 1 0';\n\nexport default {\n  createChart,\n  translate,\n  line,\n  pathFn,\n\n  MARKER_VIEWBOX,\n  ARROW,\n  ARROW_SHARP\n};\n","export const GRAPH_EVENTS = [\n  'backgroundClick',\n  'backgroundDblClick',\n  'backgroundMouseEnter',\n  'backgroundMouseLeave',\n  'backgroundCtx',\n  'nodeClick',\n  'nodeDblClick',\n  'nodeMouseEnter',\n  'nodeMouseLeave',\n  'nodeCtx',\n  'nodeSave',\n  'edgeClick',\n  'edgeMouseEnter',\n  'edgeMouseLeave',\n  'edgeCtx'\n];\n","/**\n * Recursively traverse a graph that looks like\n * {\n *   nodes: [\n *     {\n *       nodes: [\n *         {\n *           nodes: [ ... ],\n *           edges: [ ... ]\n *         }\n *       ],\n *       edges: [ ... ]\n *     },\n *     ...\n *   ],\n *   edges: [...]\n * }\n */\nexport const traverse = (root, callBackFn, depth = 0) => {\n  callBackFn(root, depth);\n  if (root.nodes) {\n    const d = depth + 1;\n    for (let i = 0; i < root.nodes.length; i++) {\n      traverse(root.nodes[i], callBackFn, d);\n    }\n  }\n};\n\n/**\n * Returns a flat representation of all nodes and edges.\n */\nexport const flatten = (root) => {\n  let nodes = [];\n  let edges = [];\n\n  traverse(root, (node, depth) => {\n    if (depth > 0) {\n      nodes = nodes.concat(node);\n    }\n    if (node.edges) {\n      edges = edges.concat(node.edges);\n    }\n  });\n  return {\n    nodes, edges\n  };\n};\n","import _ from 'lodash';\nimport * as d3 from 'd3';\n\nimport svgUtil from './utils/svg-util';\nimport { GRAPH_EVENTS } from './graph-events';\nimport { flatten, traverse, removeChildren } from './utils';\n\nconst pathFn = svgUtil.pathFn.curve(d3.curveBasis);\n\n// FIXME: This to move out\n// - moveTo => parent.depth\n// - general => edge.data.source / edge.data.target\n\n/**\n * Just make sure the viewport has a min size so it does not look\n * super large if there are only a few elements\n *\n * @param {object} v - viewport {x2, y2, x2, y2} where x2 y2 are width height respectively\n * @param {object} chartSize - { width, height } the effective size of the chart in pixels\n */\nconst ensureViewportSize = (v, chartSize) => {\n  return {\n    x1: v.x1,\n    y1: v.y1,\n    x2: Math.max(v.x2, chartSize.width),\n    y2: Math.max(v.y2, chartSize.height)\n  };\n};\n\n\n// TODO\n// - Add/Remove without relayout\n// - Edge/node look up performance\n// - Cull edges is buggy\n\n/**\n * Base support for rendering and manipulating a compound/nested graph.\n *\n * 1. It setups a bare-bone rendering skeleton, In the sense that it renders empty group-nodes and move them\n * into their respective layout positions. It is up to the implementation class to provide the actual rendering\n * functions, which are:\n *\n * Basic rendering mode - redraws everything at every render-loop\n * - renderNode\n * - renderEdge\n *\n * Delta rendering mode - redraws added/removed/updated objects\n * - renderNodeAdded\n * - renderNodeUpdated\n * - renderNodeRemoved\n * - renderEdgeAdded\n * - renderEdgeUpdated\n * - renderEdgeRemoved\n *\n * Common/Misc\n * - renderEdgeControl\n *\n * 2. Provides utility functions to navigate and to manipulate the graph object.\n * - Center on a given node with respect to the container\n * - Highlight a set of nodes/edges\n * - Collapse and expand compound nodes\n * - Focus/enlarge leaf nodes\n * - De-clutter/cull-out edges whose source/targets are not in the viewport\n *\n * The input specification consist of two things\n * - Graph data specified as a set of nodes and edges\n * - A configuration object to specify the rendering parameters\n *\n * The renderer itself is layout agnostic, it relies upon and expects a layout adapter to be\n * provided as a part of the configuration object. Moreover it expect the adapter to expose a\n * \"run()\" and \"makeRenderingGraph()\" methods.\n */\nexport default class SVGRenderer {\n  /**\n   * Create Elk graph renderer\n   *\n   * @param {HTMLElement} options.el - A container element that contains the rendered graph\n   * @param {object} options - Renderer options\n   * @param {object} options.adapter - Layout adapter\n   * @param {string} options.renderMode - \"basic\" or \"delta\" modes. The basic mode provides new data-bindings\n   *   every single render loop, where the deta mode provides added/updated/delete objects and allows you to\n   *   handle them separately with different effects.\n   * @param {boolean} options.useEdgeControl - Whether to use edge controls, default to false\n   * @param {string} options.edgeControlOffsetType - \"percentage\" or \"unit\"\n   * @param {numbeer} options.edgeControlOffset - If type is percentage this should be between 0 an 1,\n   *   if unit then a positive value is an offset from the source, and a negative offset from the target.\n   * @param {boolean} options.useDebugger - prints debugging information\n   */\n  constructor(options) {\n    this.data = {};\n    this.registry = {};\n    this.options = options || {};\n    this.options.renderMode = this.options.renderMode || 'basic';\n    this.options.useEdgeControl = this.options.useEdgeControl || false;\n    this.options.edgeControlOffsetType = this.options.edgeControlOffsetType || 'percentage';\n    this.options.edgeControlOffset = this.options.edgeControlOffset || 0.66;\n    this.options.useDebugger = this.options.useDebugger || false;\n    this.options.addons = this.options.addons || [];\n\n    // Primitive add-on system\n    this.options.addons.forEach(addon => {\n      addon(this).forEach(d => {\n        this[d.name] = d.fn;\n      });\n    });\n\n    this.adapter = this.options.adapter;\n\n    this.parentEl = null;\n    this.svgEl = null;\n\n    this.chart = null; // D3 chart reference\n    this.chartSize = { width: 1, height: 1 };\n\n    // The graph data + positions\n    this.layout = null;\n\n    if (options.el) {\n      this.initialize(options.el);\n    } else {\n      throw new Error('options must provide an element for graph rendering');\n    }\n\n    // Internal trackers\n    this.zoom = null;\n\n\n    // Refernece tracker, key nodes' identifiers. This essentially tracks the before-collapse state\n    this.collapseTracker = {};\n    this.hiddenEdges = {};\n  }\n\n  setCallback(name, fn) {\n    if (GRAPH_EVENTS.indexOf(name) === -1) {\n      throw new Error(`Failed to register callback, unknown name ${name}`);\n    } else {\n      this.registry[name] = fn;\n    }\n  }\n\n  unsetCallback(name) {\n    delete this.registry[name];\n  }\n\n  /**\n   * Initialize the renderer with given container element\n   * @param {HTMLElement} element - container element\n   */\n  initialize(element) {\n    this.parentEl = element;\n    this.chartSize.width = this.parentEl.clientWidth;\n    this.chartSize.height = this.parentEl.clientHeight;\n\n    this.svgEl = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    removeChildren(this.parentEl).appendChild(this.svgEl);\n    this.svgEl.style.userSelect = 'none';\n  }\n\n  /**\n   * Set graph data\n   * @param {Object} data - a graph model data\n   */\n  setData(data) {\n    this.data = data;\n    this.layout = null; // clear previous layout since it needs to be updated\n  }\n\n\n  /**\n   * Renders the graph\n   */\n  async render() {\n    const options = this.options;\n    if (!this.layout) {\n      this.layout = await this.runLayout();\n    }\n\n    // Addresses the case where swapping layout introduce sufficient changes that\n    // we need to recalculate the viewport dimensions\n    if (!this.chart) {\n      this.chart = this._createChart();\n    } else {\n      const x1 = 0;\n      const y1 = 0;\n      const x2 = this.layout.width;\n      const y2 = this.layout.height;\n      const vp = ensureViewportSize({ x1, y1, x2, y2 }, this.chartSize);\n      d3.select(this.svgEl).attr('viewBox', `${vp.x1} ${vp.y1} ${vp.x2} ${vp.y2}`);\n\n      // Reset zoom\n      const svg = d3.select(this.svgEl);\n      svg.transition().call(\n        this.zoom.transform,\n        d3.zoomIdentity\n      );\n\n      const maxZoom = Math.max(2, Math.floor(this.layout.width / this.chartSize.width));\n      this.zoom.scaleExtent([0.5, maxZoom]);\n    }\n\n    this.buildDefs();\n\n    if (options.renderMode === 'basic') {\n      this.renderNodes();\n      this.renderEdges();\n    } else {\n      this.renderNodesDelta();\n      this.renderEdgesDelta();\n    }\n\n    if (options.useEdgeControl) {\n      this.renderEdgeControls();\n    }\n\n    this._enableDrag();\n    if (options.useDebugger) {\n      this.renderDebug();\n    }\n    this._enableInteraction();\n  }\n\n  // FIXME: Should provide very basic marker definitions and leave the work to the\n  // implementation renderers\n  buildDefs() {\n    const svg = d3.select(this.svgEl);\n    const edges = flatten(this.layout).edges;\n\n    // Clean up\n    svg.select('defs').selectAll('.edge-marker-end').remove();\n\n    svg.select('defs')\n      .selectAll('.edge-marker-end')\n      .data(edges)\n      .enter()\n      .append('marker')\n      .classed('edge-marker-end', true)\n      .attr('id', d => {\n        const source = d.data.source.replace(/\\s/g, '');\n        const target = d.data.target.replace(/\\s/g, '');\n        return `arrowhead-${source}-${target}`;\n      })\n      .attr('viewBox', svgUtil.MARKER_VIEWBOX)\n      .attr('refX', 2)\n      .attr('refY', 0)\n      .attr('orient', 'auto')\n      .attr('markerWidth', 15)\n      .attr('markerHeight', 15)\n      .attr('markerUnits', 'userSpaceOnUse')\n      .attr('xoverflow', 'visible')\n      .append('svg:path')\n      .attr('d', svgUtil.ARROW)\n      .style('fill', '#000')\n      .style('stroke', 'none');\n  }\n\n\n  /**\n   * A fancier version of renderEdges, figure out the delta between\n   * different layout runs and provide access to added, updated, and\n   * removed graph elements.\n   */\n  renderEdgesDelta() {\n    const chart = this.chart;\n    let allEdges = [];\n\n    traverse(this.layout, (node) => {\n      if (node.edges && node.edges.length > 0) {\n        allEdges = allEdges.concat(node.edges);\n      }\n    });\n\n    const edgesGroup = chart.selectAll('.edge').data(allEdges, d => d.id);\n\n    // Scaffold added/updated/removed\n    const newEdges = edgesGroup.enter().append('g').classed('edge', true);\n\n    edgesGroup.exit().each(d => (d.state = 'removed'));\n    newEdges.each(d => (d.state = 'new'));\n    edgesGroup.each(d => (d.state = 'updated'));\n\n    // Rebind because children point to different reference\n    chart.selectAll('.edge').filter(d => d.state === 'updated').each(function(d) {\n      d3.select(this).selectAll('.edge-path').datum(d);\n    });\n\n\n    chart.selectAll('.edge').filter(d => d.state === 'new').call(this.renderEdgeAdded);\n    chart.selectAll('.edge').filter(d => d.state === 'updated').call(this.renderEdgeUpdated);\n    chart.selectAll('.edge').filter(d => d.state === 'removed').call(this.renderEdgeRemoved);\n  }\n\n  renderEdges() {\n    const chart = this.chart;\n    chart.selectAll('.edge').remove();\n\n    const _recursiveBuild = (n) => {\n      if (n.nodes) {\n        n.nodes.forEach(node => {\n          _recursiveBuild(node);\n        });\n      }\n      if (!n.edges) return;\n\n      chart.selectAll('.edge')\n        .data(n.edges, d => d.id)\n        .enter().append('g')\n        .classed('edge', true);\n    };\n    _recursiveBuild(this.layout);\n    chart.selectAll('.edge').call(this.renderEdge);\n  }\n\n\n  /**\n   * A fancier version of renderNodes, figures out the delta between\n   * different layout runs and provide access to added, updated, and\n   * removed graph elements.\n   */\n  renderNodesDelta() {\n    const chart = this.chart;\n\n    const _recursiveBuild = (selection, childrenNodes) => {\n      if (!childrenNodes) return;\n\n      const nodesGroup = selection.selectAll('.node').filter(function() {\n        return this.parentNode === selection.node();\n      }).data(childrenNodes, d => d.id);\n\n      const newNodes = nodesGroup.enter().append('g')\n        .classed('node', true);\n\n      // nodesGroup.exit().remove();\n      nodesGroup.exit().each(d => (d.state = 'removed'));\n      newNodes.each(d => (d.state = 'new'));\n      nodesGroup.each(d => (d.state = 'updated'));\n\n      [newNodes, nodesGroup].forEach(g => {\n        g.each(function(d) {\n          const selection = d3.select(this);\n\n          // Allocate for the node itself\n          if (selection.select('.node-ui').size() === 0) {\n            selection.append('g').classed('node-ui', true);\n          }\n          selection.select('.node-ui').datum(d);\n\n          // Allocate for the node's children\n          if (selection.select('.node-children').size() === 0) {\n            selection.append('g').classed('node-children', true);\n          }\n          _recursiveBuild(selection.select('.node-children'), d.nodes);\n        });\n\n        g.transition().duration(1000).attr('transform', d => {\n          return svgUtil.translate(d.x, d.y);\n        });\n      });\n    };\n    _recursiveBuild(chart, this.layout.nodes);\n\n    chart.selectAll('.node-ui').filter(d => d.state === 'new').call(this.renderNodeAdded);\n    chart.selectAll('.node-ui').filter(d => d.state === 'updated').call(this.renderNodeUpdated);\n    chart.selectAll('.node-ui').filter(d => d.state === 'removed').call(this.renderNodeRemoved);\n  }\n\n  /**\n   * Simple basic renderNodes, just wipe out all nodes and redraw\n   */\n  renderNodes() {\n    const chart = this.chart;\n    chart.selectAll('.node').remove();\n\n    const _recursiveBuild = (selection, childrenNodes) => {\n      if (!childrenNodes) return;\n      const nodesGroup = selection.selectAll('.node')\n        .data(childrenNodes)\n        .enter().append('g')\n        .classed('node', true)\n        .attr('transform', d => {\n          return svgUtil.translate(d.x, d.y);\n        });\n\n      nodesGroup.each(function(d) {\n        const s = d3.select(this);\n        s.append('g').classed('node-ui', true);\n        _recursiveBuild(s.append('g'), d.nodes);\n      });\n    };\n    _recursiveBuild(chart, this.layout.nodes);\n    chart.selectAll('.node-ui').call(this.renderNode);\n  }\n\n  calculateEdgeControlPlacement(pathNode) {\n    const options = this.options;\n    let pos = 0;\n    const total = pathNode.getTotalLength();\n    const offset = options.edgeControlOffset;\n    if (options.edgeControlOffsetType === 'percentage') {\n      pos = offset * total;\n    } else {\n      pos = offset > 0 ? offset : Math.max(0, (total + offset));\n    }\n    const controlPoint = pathNode.getPointAtLength(pos);\n    return controlPoint;\n  }\n\n  /**\n   * Renders a controller UI element along the edge path\n   */\n  renderEdgeControls() {\n    const chart = this.chart;\n    const edges = chart.selectAll('.edge');\n    edges.selectAll('.edge-control').remove();\n\n    const self = this;\n\n    edges.each(function() {\n      const pathNode = d3.select(this).select('path').node();\n      const controlPoint = self.calculateEdgeControlPlacement(pathNode);\n      d3.select(this).append('g')\n        .classed('edge-control', true)\n        .attr('transform', svgUtil.translate(controlPoint.x, controlPoint.y));\n    });\n    chart.selectAll('.edge-control').call(this.renderEdgeControl);\n  }\n\n  /**\n   * Debugging information\n   */\n  renderDebug() {\n    const chart = this.chart;\n    const options = this.options;\n    const chartSize = this.chartSize;\n    const background = d3.select(this.svgEl).select('.background-layer');\n    const width = this.layout.width < chartSize.width ? chartSize.width : this.layout.width;\n    const height = this.layout.height < chartSize.height ? chartSize.height : this.layout.height;\n    const halfW = 0.5 * width;\n    const halfH = 0.5 * height;\n    const gridData = [\n      [-5000, halfH, 5000, halfH],\n      [halfW, -5000, halfW, 5000]\n    ];\n\n    background.selectAll('.info').remove();\n    const info = background.append('g').classed('info', true);\n\n    const t = d3.zoomTransform(chart.node());\n    info.append('text').text('TS: ' + t.k.toFixed(2));\n    info.append('text').text('TX: ' + t.x.toFixed(2));\n    info.append('text').text('TY: ' + t.y.toFixed(2));\n    info.append('text').text('Mode: ' + options.renderMode);\n    info.selectAll('text')\n      .attr('x', 3)\n      .attr('y', (d, i) => (i + 1) * 14)\n      .style('font-size', '10px');\n\n\n    background.selectAll('.grid').remove();\n    background.selectAll('.grid')\n      .data(gridData)\n      .enter()\n      .append('path')\n      .classed('grid', true)\n      .attr('d', d => svgUtil.line(...d))\n      .style('fill', 'none')\n      .style('stroke', '#00F')\n      .style('stroke-width', 1.5)\n      .style('opacity', 0.5);\n  }\n\n  async runLayout() {\n    const renderingGraph = this.adapter.makeRenderingGraph(this.data);\n    const layout = this.adapter.run(renderingGraph);\n    return layout;\n  }\n\n\n  /**\n   * Highlight a subgraph with gaussian blur\n   *\n   * @param {object} options - highlight options\n   * @param {string} options.color - highlight color\n   * @param {number} options.duration - highlight duration\n   */\n  highlight({ nodes, edges }, options) {\n    const svg = d3.select(this.svgEl);\n    const chart = this.chart;\n\n    const color = options.color || 'red';\n    const duration = options.duration || 2000;\n\n    const highlightId = `glow${(new Date()).getTime()}`;\n\n    // Reset\n    // svg.select('#glow').remove();\n\n    // Add temporary filter definition\n    const filter = svg.select('defs')\n      .append('filter')\n      .attr('id', highlightId)\n      .attr('width', '200%')\n      .attr('filterUnits', 'userSpaceOnUse');\n\n    filter.append('feGaussianBlur')\n      .attr('stdDeviation', 4.5)\n      .attr('result', 'blur');\n\n    filter.append('feOffset')\n      .attr('in', 'blur')\n      .attr('result', 'offsetBlur')\n      .attr('dx', 0)\n      .attr('dy', 0)\n      .attr('x', -10)\n      .attr('y', -10);\n\n    filter.append('feFlood')\n      .attr('in', 'offsetBlur')\n      .attr('flood-color', color)\n      .attr('flood-opacity', 0.95)\n      .attr('result', 'offsetColor');\n\n    filter.append('feComposite')\n      .attr('in', 'offsetColor')\n      .attr('in2', 'offsetBlur')\n      .attr('operator', 'in')\n      .attr('result', 'offsetBlur');\n\n\n    const feMerge = filter.append('feMerge');\n    feMerge.append('feMergeNode')\n      .attr('in', 'offsetBlur');\n\n    feMerge.append('feMergeNode')\n      .attr('in', 'SourceGraphic');\n\n\n    // Apply filter\n    // FIXME: not very efficient\n    const hNodes = chart.selectAll('.node').filter(d => { return nodes.includes(d.id); });\n    hNodes.style('filter', `url(#${highlightId})`).classed(`${highlightId}`, true);\n\n    const hEdges = chart.selectAll('.edge').filter(d => { return _.some(edges, edge => edge.source === d.data.source && edge.target === d.data.target); });\n    hEdges.style('filter', `url(#${highlightId})`).classed(`${highlightId}`, true);\n\n    svg.select(`#${highlightId}`).select('feGaussianBlur')\n      .transition()\n      .duration(duration)\n      .attr('stdDeviation', 0)\n      .on('end', () => {\n        hNodes.style('filter', null);\n        hEdges.style('filter', null);\n      });\n\n    return highlightId;\n  }\n\n  unHighlight(id) {\n    const svg = d3.select(this.svgEl);\n    svg.select(`#${id}`).remove();\n    svg.selectAll(`.${id}`).style('filter', null);\n  }\n\n  /**\n   * Centralize provided node in the SVG canvas\n   *\n   * @param {string} nodeId - id\n   * @param {number} duration - animation transition time in millis\n   *\n   * See: https://observablehq.com/@d3/programmatic-zoom\n   */\n  moveTo(nodeId, duration) {\n    const chart = this.chart;\n    const chartSize = this.chartSize;\n    const svg = d3.select(this.svgEl);\n    const width = this.layout.width < chartSize.width ? chartSize.width : this.layout.width;\n    const height = this.layout.height < chartSize.height ? chartSize.height : this.layout.height;\n\n    // t.k = scale, t.x = translateX, t.y = translateY\n    const t = d3.zoomTransform(chart.node());\n\n    const node = flatten(this.layout).nodes.find(n => n.id === nodeId);\n    if (_.isNil(node)) return;\n\n    let globalX = node.x;\n    let globalY = node.y;\n    let temp = node;\n    // while (true) {\n    //   if (_.isNil(temp.parent) || temp.parent.depth === 0) break;\n    while (temp.parent && temp.parent.depth !== 0) {\n      temp = temp.parent;\n      globalX += temp.x;\n      globalY += temp.y;\n      console.log(globalX, globalY);\n    }\n\n    const dx = globalX + 0.5 * node.width;\n    const dy = globalY + 0.5 * node.height;\n    svg.transition().duration(duration).call(\n      this.zoom.transform,\n      d3.zoomIdentity.translate(0, 0).scale(t.k).translate(\n        -dx + (0.5 * width) / t.k,\n        -dy + (0.5 * height) / t.k\n      )\n    );\n  }\n\n  /**\n   * Collapse node and all children nodes.\n   * Note edges whose source and/or target are within the collapsed node are assigned\n   * to the node.\n   *\n   * @param {string} nodeId - node identifier\n   */\n  async collapse(nodeId) {\n    // 1) Grab all nodes\n    const node = this.chart.selectAll('.node').filter(d => d.id === nodeId);\n    const childrenNodeIds = node.selectAll('.node').data().map(d => d.id);\n    const collapseTracker = this.collapseTracker;\n    const hiddenEdges = this.hiddenEdges;\n    collapseTracker[nodeId] = {};\n    collapseTracker[nodeId].edgeMap = {};\n\n    if (childrenNodeIds.length === 0) return; // Don't collapse if already a leaf node\n\n    traverse(this.layout, (node) => {\n      if (node.id === nodeId) {\n        node.width = 40;\n        node.height = 40;\n        collapseTracker[nodeId].nodes = node.nodes;\n\n        // FIXME: This is buggy, if the edges are specified 2 levels or lower it will remove them.\n        // So this means we need to either\n        // - Specify all edges at the top level, or\n        // - Shift the edges to be co-loated with one of their \"new parent\"\n        node.nodes = [];\n        node.collapsed = true;\n      }\n      if (!node.edges) return;\n\n      const hidden = _.remove(node.edges, edge => {\n        return childrenNodeIds.includes(edge.source) && childrenNodeIds.includes(edge.target);\n      });\n      if (!_.isEmpty(hidden)) {\n        hiddenEdges[nodeId] = hidden;\n      }\n\n      for (let i = 0; i < node.edges.length; i++) {\n        const edge = node.edges[i];\n        const source = edge.source;\n        const target = edge.target;\n\n        const originalEdge = {};\n        if (childrenNodeIds.includes(source)) {\n          originalEdge.source = edge.source;\n          edge.source = nodeId;\n        }\n        if (childrenNodeIds.includes(target)) {\n          originalEdge.target = edge.target;\n          edge.target = nodeId;\n        }\n\n        if (!_.isEmpty(originalEdge)) {\n          collapseTracker[nodeId].edgeMap[edge.id] = originalEdge;\n        }\n      }\n    });\n    this.layout = await this.adapter.run(this.layout);\n    this.render();\n  }\n\n  /**\n   * Expand a collapsed node, and restore the original states\n   *\n   * @param {string} nodeId - node identifier\n   */\n  async expand(nodeId) {\n    const node = this.chart.selectAll('.node').filter(d => d.id === nodeId);\n    const collapseTracker = this.collapseTracker;\n    const hiddenEdges = this.hiddenEdges;\n    const entry = collapseTracker[nodeId];\n\n    node.datum().nodes = entry.nodes;\n    node.datum().collapsed = false;\n\n    // Restore hidden edges\n    traverse(node.datum(), (n) => {\n      if ({}.hasOwnProperty.call(hiddenEdges, n.id)) {\n        // console.log('restoring for', n.id, n.collapsed);\n        if (n.collapsed === false) {\n          this.layout.edges = this.layout.edges.concat(hiddenEdges[nodeId]);\n          delete hiddenEdges[nodeId];\n        }\n      }\n    });\n\n    // Revert adjusted edges\n    traverse(this.layout, (node) => {\n      if (!node.edges) return;\n      for (let i = 0; i < node.edges.length; i++) {\n        const edge = node.edges[i];\n        if (entry.edgeMap[edge.id]) {\n          edge.target = entry.edgeMap[edge.id].target || edge.target;\n          edge.source = entry.edgeMap[edge.id].source || edge.source;\n        }\n      }\n    });\n    delete collapseTracker[nodeId];\n\n    this.layout = await this.adapter.run(this.layout);\n    this.render();\n  }\n\n\n  /**\n   * Enlarge node\n   *\n   * @param {string} nodeId\n   */\n  async focus(nodeId) {\n    const prev = this.chart.selectAll('.node').filter(d => d.focused === true);\n    if (prev.size() === 1) {\n      const datum = prev.datum();\n      delete datum.width;\n      delete datum.height;\n      delete datum.focused;\n    }\n\n    const node = this.chart.selectAll('.node').filter(d => d.id === nodeId);\n\n    // Don't enlarge compound nodes\n    if (node.nodes && node.nodes.length > 0) return;\n\n    node.datum().width = 400;\n    node.datum().height = 300;\n    node.datum().focused = true;\n\n    this.layout = await this.adapter.run(this.layout);\n    this.render();\n  }\n\n  async unfocus(nodeId) {\n    const node = this.chart.selectAll('.node').filter(d => d.id === nodeId);\n    const datum = node.datum();\n    delete datum.width;\n    delete datum.height;\n    delete datum.focused;\n    this.layout = await this.adapter.run(this.layout);\n    this.render();\n  }\n\n\n  /**\n   * Group nodes, must be at the same level (all nodes must share the same parent)\n   *\n   * @param {string} groupName\n   * @param {array} nodeIds - node identifiers\n   */\n  /*\n  async group(groupName, nodeIds) {\n    const chart = this.chart;\n\n    // 0) check parent\n    const nodesData = chart.selectAll('.node').filter(d => nodeIds.includes(d.id)).data();\n    if (_.uniq(nodesData.map(d => d.parent.id)).length !== 1) {\n      console.log('Cannot group across different levels');\n      return;\n    }\n\n    const groupNode = {\n      id: groupName,\n      label: groupName,\n      concept: groupName,\n      depth: nodesData[0].depth,\n      type: 'custom',\n      parent: nodesData[0].parent,\n      nodes: [],\n      data: { label: groupName }\n    };\n\n    // 1) Move nodes to new group\n    const parentData = nodesData[0].parent;\n    nodeIds.forEach(nodeId => {\n      const temp = _.remove(parentData.nodes, node => node.id === nodeId)[0];\n\n      // Need to create a new node wrapper to avoid double pointers problem\n      const newNode = { ...temp };\n      newNode.parent = groupNode;\n      groupNode.nodes.push(newNode);\n    });\n\n    // 2) Add new gruop node\n    parentData.nodes.push(groupNode);\n\n    this.layout = await this.adapter.run(this.layout);\n    this.render();\n  }\n  */\n\n  /**\n   * Ungroup\n   * @param {string} groupName\n   */\n  /*\n  async ungroup(groupName) {\n    const chart = this.chart;\n    const groupData = chart.selectAll('.node').filter(d => d.id === groupName).data()[0];\n    const parentData = groupData.parent;\n\n    // 0) Remove group\n    _.remove(parentData.nodes, n => n.id === groupName);\n\n    // 1) Add group children back into group parent\n    groupData.nodes.forEach(node => {\n      const temp = { ...node };\n      temp.parent = parentData;\n      parentData.nodes.push(temp);\n    });\n    delete groupData.nodes;\n\n    this.layout = await this.adapter.run(this.layout);\n    this.render();\n  }\n  */\n\n\n  // See https://github.com/d3/d3-zoom#zoomTransform\n  boundary() {\n    const chart = this.chart;\n    const t = d3.zoomTransform(chart.node());\n    const x1 = (0 - t.x) / t.k;\n    const y1 = (0 - t.y) / t.k;\n    const x2 = (this.layout.width - t.x) / t.k;\n    const y2 = (this.layout.height - t.y) / t.k;\n\n    // const x1 = 0 * t.k + t.x;\n    // const y1 = 0 * t.k + t.y;\n    // const x2 = this.layout.width * t.k + t.x;\n    // const y2 = this.layout.height * t.k + t.y;\n    return { x1, y1, x2, y2 };\n  }\n\n\n  cullEdges() {\n    const { x1, y1, x2, y2 } = this.boundary();\n\n    // Temporarily hide edges\n    this.chart.selectAll('.edge').each(function(d) {\n      const source = _.first(d.points);\n      const target = _.last(d.points);\n\n      if ((source.x < x1 || source.x > x2 || source.y < y1 || source.y > y2) &&\n          (target.x < x1 || target.x > x2 || target.y < y1 || target.y > y2)) {\n        d3.select(this).style('opacity', 0);\n      }\n    });\n  }\n\n  uncullEdges() {\n    d3.selectAll('.edge').style('opacity', 1);\n  }\n\n\n  /**\n   * Prepare the SVG and returns a chart refrence. This function will create three \"layers\": background,\n   * data, and foreground layers. The data-layer corresponds to the chart.\n   */\n  _createChart() {\n    const { width, height } = this.chartSize;\n    const viewPort = {\n      x1: 0,\n      y1: 0,\n      x2: this.layout.width,\n      y2: this.layout.height\n    };\n    const svg = d3.select(this.svgEl);\n    svg.selectAll('*').remove();\n\n    const treatedSVG = svgUtil.createChart(svg, width, height, ensureViewportSize(viewPort, this.chartSize));\n\n    // change to xMinyMin\n    treatedSVG.attr('preserveAspectRatio', 'xMidYMid meet');\n\n    // Add a debugging/background layer\n    treatedSVG.append('g').classed('background-layer', true);\n\n    // Add chart group\n    const chart = treatedSVG.append('g').classed('data-layer', true);\n\n    // Add a foreground layer\n    treatedSVG.append('g').classed('foreground-layer', true);\n\n    const _this = this;\n    function zoomed() {\n      chart.attr('transform', d3.event.transform);\n      if (_this.options.useDebugger) {\n        _this.renderDebug();\n      }\n    }\n\n    const maxZoom = Math.max(2, Math.floor(this.layout.width / this.chartSize.width));\n    this.zoom = d3.zoom().scaleExtent([0.5, maxZoom]).on('zoom', zoomed);\n    svg.call(this.zoom).on('dblclick.zoom', null);\n    return chart;\n  }\n\n  /**\n   * Standard interaction hooks, these are essentially callback functions\n   * that takes in two parameters: A d3 selection of the element, and a\n   * reference to the renderer.\n   */\n  _enableInteraction() {\n    const chart = this.chart;\n    const self = this;\n    const registry = this.registry;\n    const svg = d3.select(this.svgEl);\n    const nodes = chart.selectAll('.node');\n    const edges = chart.selectAll('.edge');\n\n    self.clickTimer = null;\n\n    const registered = (eventName) => {\n      return ({}.hasOwnProperty.call(registry, eventName));\n    };\n\n    svg.on('click', function () {\n      d3.event.stopPropagation();\n      const pointerCoords = d3.zoomTransform(svg.node()).invert(d3.mouse(this));\n      if (registered('backgroundClick')) {\n        registry.backgroundClick(d3.select(this), self, {\n          x: pointerCoords[0],\n          y: pointerCoords[1]\n        });\n      }\n    });\n\n    svg.on('dblclick', function () {\n      d3.event.stopPropagation();\n      const pointerCoords = d3.zoomTransform(svg.node()).invert(d3.mouse(this));\n      if (registered('backgroundDblClick')) {\n        registry.backgroundDblClick(d3.select(this), self, {\n          x: pointerCoords[0],\n          y: pointerCoords[1]\n        });\n      }\n    });\n\n    nodes.on('dblclick', function() {\n      d3.event.stopPropagation();\n      if (registered('nodeDblClick')) {\n        window.clearTimeout(self.clickTimer);\n        registry.nodeDblClick(d3.select(this), self);\n      }\n    });\n\n    nodes.on('click', function() {\n      d3.event.stopPropagation();\n      if (registered('nodeClick')) {\n        const _this = this;\n        window.clearTimeout(self.clickTimer);\n        self.clickTimer = window.setTimeout(() => {\n          registry.nodeClick(d3.select(_this), self);\n        }, 200);\n      }\n    });\n\n    nodes.on('mouseenter', function() {\n      d3.event.stopPropagation();\n      if (registered('nodeMouseEnter')) {\n        registry.nodeMouseEnter(d3.select(this), self);\n      }\n    });\n\n    nodes.on('mouseleave', function() {\n      d3.event.stopPropagation();\n      if (registered('nodeMouseLeave')) {\n        registry.nodeMouseLeave(d3.select(this), self);\n      }\n    });\n\n    edges.on('click', function() {\n      d3.event.stopPropagation();\n      if (registered('edgeClick')) {\n        registry.edgeClick(d3.select(this), self);\n      }\n    });\n\n    edges.on('mouseenter', function() {\n      d3.event.stopPropagation();\n      if (registered('edgeMouseEnter')) {\n        registry.edgeMouseEnter(d3.select(this), self);\n      }\n    });\n\n    edges.on('mouseleave', function() {\n      d3.event.stopPropagation();\n      if (registered('edgeMouseLeave')) {\n        registry.edgeMouseLeave(d3.select(this), self);\n      }\n    });\n  }\n\n  /**\n   * Enable node dragging, this will recalculate edge end points as well\n   */\n  _enableDrag() {\n    const chart = this.chart;\n    const options = this.options;\n    const data = flatten(this.layout);\n    const nodes = chart.selectAll('.node');\n    const self = this;\n\n    function updateEdges() {\n      chart.selectAll('.edge').selectAll('path').attr('d', d => {\n        return pathFn(d.points);\n      });\n      if (options.useEdgeControl) {\n        chart.selectAll('.edge').each(function() {\n          const pathNode = d3.select(this).select('path').node();\n          const controlPoint = self.calculateEdgeControlPlacement(pathNode);\n          d3.select(this).select('.edge-control')\n            .attr('transform', svgUtil.translate(controlPoint.x, controlPoint.y));\n        });\n      }\n    }\n\n    function dragStart() {\n      d3.event.sourceEvent.stopPropagation();\n    }\n\n    function dragMove() {\n      const node = d3.select(this);\n      const draggedIds = [node.datum().id, ...node.selectAll('.node').data().map(d => d.id)];\n\n      // Check if there is a parent container\n      const parentData = d3.select(this.parentNode).datum();\n\n      // Adjust node\n      const dx = d3.event.dx;\n      const dy = d3.event.dy;\n\n      // Short circuit\n      if (parentData) {\n        if (node.datum().x + node.datum().width + dx > (parentData.width) || node.datum().x + dx < 0) {\n          return;\n        }\n        if (node.datum().y + node.datum().height + dy > (parentData.height) || node.datum().y + dy < 0) {\n          return;\n        }\n      }\n\n      node.datum().x += dx;\n      node.datum().y += dy;\n      node.attr('transform', svgUtil.translate(node.datum().x, node.datum().y));\n      // Adjust edge\n      data.edges.forEach(edge => {\n        const source = edge.source;\n        const target = edge.target;\n\n        // FIXME: ids might not work once the graph is actually database driven.\n        if (draggedIds.includes(source) && draggedIds.includes(target)) {\n          edge.points.forEach(p => {\n            p.x += dx;\n            p.y += dy;\n          });\n        } else if (draggedIds.includes(source)) {\n          edge.points[0].x += dx;\n          edge.points[0].y += dy;\n        } else if (draggedIds.includes(target)) {\n          edge.points[edge.points.length - 1].x += dx;\n          edge.points[edge.points.length - 1].y += dy;\n        }\n      });\n\n      // update edges based on new source/target coords\n      updateEdges();\n    }\n\n    function dragEnd() {\n    }\n\n    // FIXME: Need to disable current listeners first before assigning new ones?\n    const nodeDrag = d3.drag()\n      .on('start', dragStart)\n      .on('end', dragEnd)\n      .on('drag', dragMove);\n    nodes.call(nodeDrag);\n  }\n\n  /**\n   * Given a node identifier, trace up the ancestor chain and record edges along the way\n   *\n   * @param {string} id - node identifier\n   */\n  _trace(nodeId) {\n    const checked = {};\n    const data = this.layout || { edges: [] };\n    const tracedEdges = [];\n\n    function backtrack(id) {\n      if ({}.hasOwnProperty.call(checked, id)) return;\n      checked[id] = 1;\n\n      const edges = data.edges.filter(edge => edge.data.target === id);\n      edges.forEach(edge => {\n        tracedEdges.push(edge);\n        backtrack(edge.data.source);\n      });\n    }\n    backtrack(nodeId, [nodeId]);\n\n    return {\n      edges: tracedEdges.map(edge => {\n        return { source: edge.data.source, target: edge.data.target };\n      }),\n      nodes: _.uniq([...tracedEdges.map(e => e.data.source), ...tracedEdges.map(e => e.data.target)])\n    };\n  }\n}\n","export const removeChildren = (parentElement) => {\n  while (parentElement.firstChild) {\n    parentElement.removeChild(parentElement.firstChild);\n  }\n  return parentElement;\n};\n","import _ from 'lodash';\n\nconst group = (G) => {\n  /**\n   * Group nodes, must be at the same level (all nodes must share the same parent)\n   *\n   * @param {string} groupName\n   * @param {array} nodeIds - node identifiers\n   */\n  const group = async(groupName, nodeIds) => {\n    const chart = G.chart;\n\n    // 0) check parent\n    const nodesData = chart.selectAll('.node').filter(d => nodeIds.includes(d.id)).data();\n    if (_.uniq(nodesData.map(d => d.parent.id)).length !== 1) {\n      console.log('Cannot group across different levels');\n      return;\n    }\n\n    const groupNode = {\n      id: groupName,\n      label: groupName,\n      concept: groupName,\n      depth: nodesData[0].depth,\n      type: 'custom',\n      parent: nodesData[0].parent,\n      nodes: [],\n      data: { label: groupName }\n    };\n\n    // 1) Move nodes to new group\n    const parentData = nodesData[0].parent;\n    nodeIds.forEach(nodeId => {\n      const temp = _.remove(parentData.nodes, node => node.id === nodeId)[0];\n\n      // Need to create a new node wrapper to avoid double pointers problem\n      const newNode = { ...temp };\n      newNode.parent = groupNode;\n      groupNode.nodes.push(newNode);\n    });\n\n    // 2) Add new gruop node\n    parentData.nodes.push(groupNode);\n\n    G.layout = await G.adapter.run(G.layout);\n    G.render();\n  };\n\n  /**\n   * Ungroup\n   * @param {string} groupName\n   */\n  const ungroup = async (groupName) => {\n    const chart = G.chart;\n    const groupData = chart.selectAll('.node').filter(d => d.id === groupName).data()[0];\n    const parentData = groupData.parent;\n\n    // 0) Remove group\n    _.remove(parentData.nodes, n => n.id === groupName);\n\n    // 1) Add group children back into group parent\n    groupData.nodes.forEach(node => {\n      const temp = { ...node };\n      temp.parent = parentData;\n      parentData.nodes.push(temp);\n    });\n    delete groupData.nodes;\n\n    G.layout = await G.adapter.run(G.layout);\n    G.render();\n  };\n\n  return [\n    { name: 'group', fn: group },\n    { name: 'ungroup', fn: ungroup }\n  ];\n};\n\nexport { group };\n"],"names":["createChart","svg","w","h","viewport","attr","x1","y1","x2","y2","append","translate","x","y","line","pathFn","d3","d","MARKER_VIEWBOX","ARROW","ARROW_SHARP","GRAPH_EVENTS","traverse","root","callBackFn","depth","nodes","i","length","flatten","edges","node","concat","svgUtil","curve","ensureViewportSize","v","chartSize","Math","max","width","height","SVGRenderer","options","data","registry","renderMode","this","useEdgeControl","edgeControlOffsetType","edgeControlOffset","useDebugger","addons","forEach","addon","_this2","name","fn","adapter","parentEl","svgEl","chart","layout","el","Error","initialize","zoom","collapseTracker","hiddenEdges","indexOf","element","clientWidth","clientHeight","document","createElementNS","parentElement","firstChild","removeChild","removeChildren","appendChild","style","userSelect","runLayout","vp","transition","call","transform","maxZoom","floor","scaleExtent","_createChart","buildDefs","renderNodes","renderEdges","renderNodesDelta","renderEdgesDelta","renderEdgeControls","_enableDrag","renderDebug","_enableInteraction","select","selectAll","remove","enter","classed","source","replace","target","allEdges","edgesGroup","id","newEdges","exit","each","state","filter","datum","renderEdgeAdded","renderEdgeUpdated","renderEdgeRemoved","_recursiveBuild","n","renderEdge","selection","childrenNodes","nodesGroup","parentNode","newNodes","g","size","duration","renderNodeAdded","renderNodeUpdated","renderNodeRemoved","s","renderNode","pathNode","pos","total","getTotalLength","offset","getPointAtLength","self","controlPoint","calculateEdgeControlPlacement","renderEdgeControl","background","halfW","halfH","gridData","info","t","text","k","toFixed","renderingGraph","makeRenderingGraph","run","color","highlightId","Date","getTime","feMerge","hNodes","includes","hEdges","_","some","edge","on","nodeId","find","isNil","globalX","globalY","temp","parent","console","log","dx","dy","scale","childrenNodeIds","map","edgeMap","collapsed","hidden","isEmpty","originalEdge","render","entry","hasOwnProperty","_this3","prev","focused","boundary","first","points","last","viewPort","treatedSVG","_this","clickTimer","registered","eventName","stopPropagation","pointerCoords","invert","backgroundClick","backgroundDblClick","window","clearTimeout","nodeDblClick","setTimeout","nodeClick","nodeMouseEnter","nodeMouseLeave","edgeClick","edgeMouseEnter","edgeMouseLeave","nodeDrag","sourceEvent","draggedIds","parentData","p","checked","tracedEdges","backtrack","push","uniq","e","G","group","groupName","nodeIds","nodesData","groupNode","label","concept","type","newNode","groupData"],"mappings":"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"}